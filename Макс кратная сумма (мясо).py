"""
Шестиклассник Коля совсем недавно узнал, что такое НОД и НОК — наибольший общий делитель и наименьшее общее
кратное некоторого набора натуральных чисел. Ему так понравилась эта тема, поэтому он решил потренироваться и
в случайном порядке начал выписывать на доску от 2 до 10 натуральных чисел в строчку и попарно начал находить
для них НОКи. Его друг Ваня предложил Коле следующую задачу:
из каждой строки нужно выбрать один из НОКов, причем так, чтобы их сумма была наибольшей, а также кратна 8 или 11.
В ответе укажите два числа: сначала искомое значение для файла А, затем для файла B.

Формат входных данных:
Первая строка входных данных содержит число n — количество строк, 1 ≤ n ≤ 10^5.
Следующие n строк содержат натуральное число 2 ≤ k ≤ 10, обозначающее количество чисел в строке,
затем k натуральных чисел в этой строке.
Программа должна вывести целое число — максимальную сумму, кратную 8 или 11.

Пример:
4
2 8 6
3 2 7 8
2 6 5
4 7 3 8 6

Ответом для примера будет: 152
Рассмотрим пример из условия. Для указанных входных данных значения НОК
для первой строки — 24;
для второй строки — 14,8,56;
для третьей группы — 30;
для четвёртой группы — 6,21,24,24,42,56.
Значением искомой суммы должно быть число 152 (24+ 56+ 30+ 42).
"""
def euq(t):
    a, b = t
    while max(a, b) % min(a, b) != 0:
        if a > b:
            a = a % b
        else:
            b = b % a
    return min(a, b)


def proga(f=r'/home/gora/PycharmProjects/USE-2022-informat/USE-2022-informat/test_sets/27B-32.txt'):
    with open(f, 'r') as f:
        dlin = int(f.readline())
        info = []
        meta11 = [-10000000] * 11
        meta8 = [-10000000] * 8
        meta8[0], meta11[0] = 0, 0
        for i in range(dlin):
            # преобразование входных данных в двумерный массив (строки[НОКИ])
            helper = list(map(int, f.readline().strip().split()))[1:]
            helper_s = []
            for a in range(len(helper)):
                for b in range(a + 1, len(helper)):
                    helper_s.append(helper[a] * helper[b] // euq((helper[a], helper[b])))
            info.append(list(set(helper_s)))
        for el in info:
            # для 11
            new11 = [-10000000] * 11
            for ind in range(len(el)):
                for i in range(11):
                    s_i = meta11[i] + el[ind]
                    ix_i = s_i % 11
                    new11[ix_i] = max(new11[ix_i], s_i)
            meta11 = new11
            # для 8
            new8 = [-10000000] * 8
            for ind in range(len(el)):
                for i in range(8):
                    s_i = meta8[i] + el[ind]
                    ix_i = s_i % 8
                    new8[ix_i] = max(new8[ix_i], s_i)
            meta8 = new8
        ans = max(meta8[0], meta11[0])
    return ans

print(proga())
